"""
2015 - Mike Schladt
mfv.py - collection of functions to manipulate and perform analysis of malware feature vectors
"""

import argparse
import sys
import MySQLdb 
import config as CONST
import numpy

db_host = CONST.DB_HOST
db_user = CONST.DB_USER
db_pass = CONST.DB_PASS
db_name = CONST.DB_NAME

class FeatureVector(object):
    """
    FeatureVector object stores features and basic meta related to a cuckoo analysis report
    """
    md5 = ""            #md5 of the sample analyzed 
    machine = ""        #name of the machine completing the analysis
    task_id = 0         #cuckoo task id of the analysis
    features = {}       #dictionary of feautures {'feature_name': int_value}
    
    def __init__(self, md5, machine, task_id, features):
        self.md5 = md5
        self.machine = machine
        self.task_id = task_id
        self.features = features
        self.magnitude = self.get_magnitude()
        
    def get_magnitude(self) :
        """
        Reutrns the magnitude of vector represented by self.features
        INPUT : self (FeatureVector) 
        OUTPUT : magnitude : float
        """ 
        #add vector features to 1d array   
        feature_array = []
        for key, value in self.features.iteritems() : 
            feature_array.append(value)
            
        #use numpy to return magnitude    
        return numpy.linalg.norm(numpy.array(feature_array))
        
    def get_distance(self, second_vector) :
        """
        Returns the euclidean distance between self and another FeatureVector
        INPUT : self : FeatureVector
        INPUT : second_vector : FeatureVector
        Output : distance : float
        """    
        #add vector fearues to 1D array for self
        a = []
        b = []
        for key, value in self.features.iteritems() : 
            a.append(value)
            b.append(second_vector.features[key])
            
        return numpy.linalg.norm(numpy.array(a)-numpy.array(b))    
    

            
def select_vectors(tags,machines,task_ids,hashes) :
    """
    Returns feature vectors matching the following input filters:  
    INPUT : tags : list of tuples : list of tuples representing at tags [(<tag type>, <tag value),() ]
    INPUT : machines : list : list of machines names (partial names okay)
    INPUT : task_ids : list : list of cuckoo task ids 
    INPUT : hashes  : list : list of md5 hashes
    OUTPUT : vectors : list of dicts : list of dictionaries representing vector 
                        features [{'<feature type>' : <feature value>, ...}, {} ...]   
    """
    vectors = []
    data = []
    first_filter = True #bool to determine if WHERE or AND should be appended
    cmd = "SELECT * FROM vectors" #base sql command
    
    #add tags filter
    if tags : 
        #create the search string
        sub_cmd = 'SELECT t1.md5 FROM tags t1 '
    
        #add INNER JOIN statements
        i = 1
        while i < len(tags) :
            sub_cmd += 'INNER JOIN tags t{0} ON t{1}.md5=t{2}.md5 '.format(i+1,i,i+1)
            i += 1
    
        #add WHERE clause 
        i = 0 
        while i < len(tags) :
            if i == 0 : 
                sub_cmd += 'WHERE t{0}.type=%s AND t{0}.value=%s '.format(i+1)
            else :
                sub_cmd += 'AND t{0}.type=%s AND t{0}.value=%s '.format(i+1)
            data.append(tags[i][0])
            data.append(tags[i][1])
            i += 1
        
        if first_filter : 
            cmd = "{0} WHERE (md5 in ({1}))".format(cmd, sub_cmd)
            first_filter = False
        else :
            cmd = "{0} AND (md5 in ({1}))".format(cmd, sub_cmd)    
    
    #add machine filter
    if machines :
        sub_cmd = "(machine LIKE %s) "
        data.append('%' + machines.pop(0) + '%') 
        for machine in machines : 
            sub_cmd += "OR (machine LIKE %s) "
            data.append('%' + machine + '%')
        
        if first_filter : 
            cmd = "{0} WHERE ({1})".format(cmd, sub_cmd)
            first_filter = False
        else :
            cmd = "{0} AND ({1})".format(cmd, sub_cmd)
    
    #add task_id filter
    if task_ids :
        sub_cmd = "(task_id=%s) "
        data.append(int(task_ids.pop(0))) 
        for task_id in task_ids : 
            sub_cmd += "OR (task_id=%s) "
            data.append(int(task_id))
        
        if first_filter : 
            cmd = "{0} WHERE ({1})".format(cmd, sub_cmd)
            first_filter = False
        else :
            cmd = "{0} AND ({1})".format(cmd, sub_cmd)

    #add hash filter
    if hashes :
        sub_cmd = "(md5=%s) "
        data.append(hashes.pop(0)) 
        for md5 in hashes : 
            sub_cmd += "OR (md5=%s) "
            data.append(md5)
        
        if first_filter : 
            cmd = "{0} WHERE ({1})".format(cmd, sub_cmd)
            first_filter = False
        else :
            cmd = "{0} AND ({1})".format(cmd, sub_cmd)            
    #DEBUG
    #print cmd
    #print data
                
    #connect to db and execute command
    connection = MySQLdb.connect(db_host, db_user, db_pass, db_name)
    cursor = connection.cursor()
    cursor.execute(cmd, data)
    results = cursor.fetchall()
    if not results : 
        return False
    connection.close()
    vectors = []
    
    #create the malware feature vector object
    current_analysis_info = '{0},{1},{2}'.format(results[0][0],results[0][1],results[0][2])    
    md5 = results[0][0].strip()
    machine = results[0][1]
    task_id = results[0][2]
    features = {}
    i = 0
    for result in results :
        #add feature to dictionary 
        features[result[3]] = result[4]
        
        #find information for next result entry
        try :
            next_analysis_info = '{0},{1},{2}'.format(results[i+1][0],results[i+1][1],results[i+1][2])
        except :
            #add features vector to vectors list
            vector = FeatureVector(md5,machine,task_id,features)
            vectors.append(vector)
            continue #reached the end of results
        
        #check if next result entry is same vector  
        if  next_analysis_info != current_analysis_info : 
            #add features vector to vectors list
            vector = FeatureVector(md5,machine,task_id,features)
            vectors.append(vector)
            #set current analysis info to next analysis info
            current_analysis_info = next_analysis_info 
            #seed values for the next vector object 
            md5 = results[i+1][0]
            machine = results[i+1][1]
            task_id = results[i+1][2]         
            features = {}
        i += 1
    
    return vectors
    
def get_args() : 
    """
    Retrieves main function arguments
    INPUT : NONE
    OUTPUT : list : parsed arguments
    """
    parser = argparse.ArgumentParser(description='Collection of helper functions to maniputlate and perform maths on vectors')
    subparsers = parser.add_subparsers()

    select = subparsers.add_parser('print', help='Prints feature vectors. Filtered by provided tags')
    select.add_argument('-t', '--tag', 
        help="Specify tag type/value pairs to filter on. Example : '-t family,dyre source,bit9'", nargs='+')    
    select.add_argument('-m', '--machine', 
        help="Specify machine name to filter on (partial names okay). Example : '-m win7x64'", nargs='+')
    select.add_argument('-c', '--cuckoo_task_id', 
        help="Specify cuckoo task id filter on. Example : '-c 710'", nargs='+') 
    select.add_argument('--md5', 
        help="Specify MD5 hash to filter on. Example : '-h 84bb1c8c5957125029e4fbfa9ec63045'", nargs='+')
    select.add_argument('--csv', 
        help="Print in CSV format", action='store_true')                    
    select.set_defaults(subparser='print')
    
    mean = subparsers.add_parser('mean', help='Prints vector representing the mean of all vectors matching input filters')
    mean.add_argument('-t', '--tag', 
        help="Specify tag type/value pairs to filter on. Example : '-t family,dyre source,bit9'", nargs='+')    
    mean.add_argument('-m', '--machine', 
        help="Specify machine name to filter on (partial names okay). Example : '-m win7x64'", nargs='+')
    mean.add_argument('-c', '--cuckoo_task_id', 
        help="Specify cuckoo task id filter on. Example : '-c 710'", nargs='+') 
    mean.add_argument('--md5', 
        help="Specify MD5 hash to filter on. Example : '-h 84bb1c8c5957125029e4fbfa9ec63045'", nargs='+')
    mean.add_argument('--csv', 
        help="Print in CSV format", action='store_true')                    
    mean.set_defaults(subparser='mean')
    
    stddev = subparsers.add_parser('stddev', help='Prints vector representing the standard deviation of vectors matching input filters')
    stddev.add_argument('-t', '--tag', 
        help="Specify tag type/value pairs to filter on. Example : '-t family,dyre source,bit9'", nargs='+')    
    stddev.add_argument('-m', '--machine', 
        help="Specify machine name to filter on (partial names okay). Example : '-m win7x64'", nargs='+')
    stddev.add_argument('-c', '--cuckoo_task_id', 
        help="Specify cuckoo task id filter on. Example : '-c 710'", nargs='+') 
    stddev.add_argument('--md5', 
        help="Specify MD5 hash to filter on. Example : '-h 84bb1c8c5957125029e4fbfa9ec63045'", nargs='+')
    stddev.add_argument('--csv', 
        help="Print in CSV format", action='store_true')                    
    stddev.set_defaults(subparser='stddev')
    return parser.parse_args()
    
def parse_select_args(args) :
    """
    Parses 'select' option argum
    INPUT : args : list of arguments parsed with argparse
    OUTPUT : tag, machines, task_ids, hashes
    """
    #add tags
    if args.tag :
        tags = []
        for tag in args.tag :     
            tag = tag.split(',')
            tags.append((tag[0].strip(),tag[1].strip()))
    else :
        tags = None
    
    #add machines
    if args.machine : 
        machines = []
        for machine in args.machine :
            machines.append(machine.strip())                
    else :
        machines = None
    
    #add task_ids    
    if args.cuckoo_task_id :
        task_ids = []
        for task_id in args.cuckoo_task_id : 
            task_ids.append(task_id.strip())    
    else :
        task_ids = None
    
    #add hashes
    if args.md5 :
        hashes = [] 
        for md5 in args.md5 :
             hashes.append(md5.strip())
    else :
        hashes = None
    
    return tags,machines,task_ids,hashes
    
def stats_mean(vectors) :
    """
    Stats fuction returns a single feature set representing the averga 
    INPUT: vectors : list of FeatureVector objects 
    OUTPUT: mean_vector : FeatureVector : a meta FeatureVector representing the mean feature values 
    """
    
    #get keys - all vectors must contain keys found in first vector
    keys = []
    for key, value in vectors[0].features.iteritems() :
        keys.append(key)
    
    #sort the keys    
    keys = sorted(keys)    
    
    feature_arrays = [] #array of feature arrays
    for vector in vectors : 
        feature_array = [] #single feature array
    
        for key in keys :      
            feature_array.append(vector.features[key])

        #append feature array to feature_arrays
        feature_arrays.append(feature_array)
        
    #use numpy to return 1D array representing the mean arary of the inputs
    mean_feature_array = numpy.mean(numpy.array(feature_arrays),axis=0)
    #add mean features list to dictionary values 
    mean_features = {}
    i = 0
    for key in keys :
        mean_features[key] = mean_feature_array[i]
        i += 1
    
    #add mean features to a FeatureVector object    
    mean_vector = FeatureVector(None,None,None,mean_features)    
    return mean_vector

def stats_stddev(vectors) :
    """
    Stats fuction returns a single feature set representing the standard devation for each feature 
    INPUT: vectors : list of FeatureVector objects 
    OUTPUT: stddev_vector : FeatureVector : a meta FeatureVector representing the standard deviations  
    """
    
    #get keys - all vectors must contain keys found in first vector
    keys = []
    for key, value in vectors[0].features.iteritems() :
        keys.append(key)
    
    #sort the keys    
    keys = sorted(keys)    
    
    feature_arrays = [] #array of feature arrays
    for vector in vectors : 
        feature_array = [] #single feature array
    
        for key in keys :      
            feature_array.append(vector.features[key])

        #append feature array to feature_arrays
        feature_arrays.append(feature_array)
        
    #use numpy to return 1D array representing the stddev arary of the inputs
    stddev_feature_array = numpy.std(numpy.array(feature_arrays),axis=0)
    #add mean features list to dictionary values 
    stddev_features = {}
    i = 0
    for key in keys :
        stddev_features[key] = stddev_feature_array[i]
        i += 1
    
    #add stddev features to a FeatureVector object    
    stddev_vector = FeatureVector(None,None,None,stddev_features)    
    return stddev_vector
    
def print_verbose(vectors) :
    """
    INPUT : vectors : list of FeatureVector objects
    OUTPUT : None : verbosly prints to stdout
    """
    for vector in vectors : 
        print "---------------------------------"
        print "Vector Information: "
        if vector.md5 : 
            print "MD5 : {0}".format(vector.md5)
        if vector.machine :
            print "Machine : {0}".format(vector.machine)
        if vector.task_id :
            print "Task ID : {0}".format(vector.task_id)
        print "Vector Magnitude : {0}".format(vector.magnitude)
        print "---------------------------------"
        print
        for key, value in vector.features.iteritems() :
            print "\t{0:60} {1}".format(key, value) 
        print

def print_csv(vectors) :
    """
    INPUT : vectors : list of FeatureVector objects
    OUTPUT : None : prints csv to stdout
    """
    #print headers
    entry = vectors[0]
    outline = ""
    if entry.md5 and entry.machine and entry.task_id : 
        outline += "md5,machine,task_id"
    for key, value in entry.features.iteritems() :
        outline += ",{0}".format(key)
    outline = outline.strip(",")
    outline = outline.strip()
    print outline

    #print values
    for vector in vectors :
        outline = ""
        if entry.md5 and entry.machine and entry.task_id :
            outline += "{0},{1},{2}".format(vector.md5,vector.machine,vector.task_id)
        for key, value in vector.features.iteritems() :
            outline += ",{0}".format(value)
        outline = outline.strip(",")
        outline = outline.strip()
        print outline
                
if __name__ == '__main__' :
    #get input args
    args = get_args()

    #select sub-command
    if args.subparser == 'print' :
        tags, machines, task_ids, hashes = parse_select_args(args)
        vectors = select_vectors(tags, machines, task_ids, hashes)
        if vectors :      
            if args.csv : 
                print_csv(vectors)
            else :
                print_verbose(vectors)     
        else : 
            print "No results for provided filters"     
    
    #mean subcommand                
    elif args.subparser == 'mean' :
        tags, machines, task_ids, hashes = parse_select_args(args)
        vectors = select_vectors(tags, machines, task_ids, hashes)
        if vectors : 
            mean_vector = stats_mean(vectors)
            if args.csv : 
                print_csv([mean_vector])
            else :
                print_verbose([mean_vector])
        else :
            print "No results for provided filters"
            
    #stddev subcommand                
    elif args.subparser == 'stddev' :
        tags, machines, task_ids, hashes = parse_select_args(args)
        vectors = select_vectors(tags, machines, task_ids, hashes)
        if vectors :
            stddev_vector = stats_stddev(vectors)
            if args.csv : 
                print_csv([stddev_vector])
            else :
                print_verbose([stddev_vector])
        else :
            print "No results for provided filters"                